<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS基础 | 博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="教程、技术、问题总结">
    
    <link rel="preload" href="/blog/assets/css/0.styles.f2fa720d.css" as="style"><link rel="preload" href="/blog/assets/js/app.7d9bf940.js" as="script"><link rel="preload" href="/blog/assets/js/3.ce84a6f3.js" as="script"><link rel="preload" href="/blog/assets/js/1.22a35a13.js" as="script"><link rel="preload" href="/blog/assets/js/30.4cb7387c.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.453fc3a7.js"><link rel="prefetch" href="/blog/assets/js/11.fb48d55e.js"><link rel="prefetch" href="/blog/assets/js/12.ed62ecd3.js"><link rel="prefetch" href="/blog/assets/js/13.259cafe2.js"><link rel="prefetch" href="/blog/assets/js/14.b5706a18.js"><link rel="prefetch" href="/blog/assets/js/15.50ab0f5e.js"><link rel="prefetch" href="/blog/assets/js/16.2ce9f822.js"><link rel="prefetch" href="/blog/assets/js/17.3f77f2c1.js"><link rel="prefetch" href="/blog/assets/js/18.37c5a3a1.js"><link rel="prefetch" href="/blog/assets/js/19.54cbb3d9.js"><link rel="prefetch" href="/blog/assets/js/20.93159361.js"><link rel="prefetch" href="/blog/assets/js/21.633f3323.js"><link rel="prefetch" href="/blog/assets/js/22.856d4227.js"><link rel="prefetch" href="/blog/assets/js/23.7e873d2a.js"><link rel="prefetch" href="/blog/assets/js/24.85d12ad4.js"><link rel="prefetch" href="/blog/assets/js/25.bc6e173f.js"><link rel="prefetch" href="/blog/assets/js/26.5c44f3d9.js"><link rel="prefetch" href="/blog/assets/js/27.a5739f26.js"><link rel="prefetch" href="/blog/assets/js/28.c2d3ac54.js"><link rel="prefetch" href="/blog/assets/js/29.61e306a5.js"><link rel="prefetch" href="/blog/assets/js/31.c0ca0d3b.js"><link rel="prefetch" href="/blog/assets/js/32.3f90dd0a.js"><link rel="prefetch" href="/blog/assets/js/33.7809403c.js"><link rel="prefetch" href="/blog/assets/js/34.7b1c8273.js"><link rel="prefetch" href="/blog/assets/js/35.1b1347bf.js"><link rel="prefetch" href="/blog/assets/js/36.d32cc0cd.js"><link rel="prefetch" href="/blog/assets/js/37.d6ca1cba.js"><link rel="prefetch" href="/blog/assets/js/38.d01e00fd.js"><link rel="prefetch" href="/blog/assets/js/39.2278f3af.js"><link rel="prefetch" href="/blog/assets/js/4.9e541bfd.js"><link rel="prefetch" href="/blog/assets/js/40.03dfd0c2.js"><link rel="prefetch" href="/blog/assets/js/41.66ed9651.js"><link rel="prefetch" href="/blog/assets/js/42.30e79db3.js"><link rel="prefetch" href="/blog/assets/js/43.c8a063dd.js"><link rel="prefetch" href="/blog/assets/js/5.d342f67a.js"><link rel="prefetch" href="/blog/assets/js/6.1709955f.js"><link rel="prefetch" href="/blog/assets/js/7.25ac339c.js"><link rel="prefetch" href="/blog/assets/js/8.540f2a1f.js"><link rel="prefetch" href="/blog/assets/js/9.89a08dc2.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.f2fa720d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>博客</h3> <p class="description" data-v-59e6cb88>教程、技术、问题总结</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      教程
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/guide/markd.html" class="nav-link"><i class="undefined"></i>
  markdown语法
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/seo.html" class="nav-link"><i class="undefined"></i>
  SEO解决方案
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/js/basic.html" aria-current="page" class="nav-link router-link-exact-active router-link-active"><i class="undefined"></i>
  javaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/css/basic.html" class="nav-link"><i class="undefined"></i>
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/vue/vue3/basic.html" class="nav-link"><i class="undefined"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/git/svn.html" class="nav-link"><i class="undefined"></i>
  Git
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/yarn/basic.html" class="nav-link"><i class="undefined"></i>
  Yarn
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/plugins/iconPicker.html" class="nav-link"><i class="undefined"></i>
  插件
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/nuxt/basic.html" class="nav-link"><i class="undefined"></i>
  nuxt
</a></li></ul></div></div><div class="nav-item"><a href="/blog/websites/links.html" class="nav-link"><i class="undefined"></i>
  网址
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>33</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>3</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      教程
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/guide/markd.html" class="nav-link"><i class="undefined"></i>
  markdown语法
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/seo.html" class="nav-link"><i class="undefined"></i>
  SEO解决方案
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/js/basic.html" aria-current="page" class="nav-link router-link-exact-active router-link-active"><i class="undefined"></i>
  javaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/css/basic.html" class="nav-link"><i class="undefined"></i>
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/vue/vue3/basic.html" class="nav-link"><i class="undefined"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/git/svn.html" class="nav-link"><i class="undefined"></i>
  Git
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/yarn/basic.html" class="nav-link"><i class="undefined"></i>
  Yarn
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/plugins/iconPicker.html" class="nav-link"><i class="undefined"></i>
  插件
</a></li><li class="dropdown-item"><!----> <a href="/blog/guide/nuxt/basic.html" class="nav-link"><i class="undefined"></i>
  nuxt
</a></li></ul></div></div><div class="nav-item"><a href="/blog/websites/links.html" class="nav-link"><i class="undefined"></i>
  网址
</a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>javaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/guide/js/basic.html" aria-current="page" class="active sidebar-link">JS基础</a></li><li><a href="/blog/guide/js/array.html" class="sidebar-link">数组常用方法（一）</a></li><li><a href="/blog/guide/js/id.html" class="sidebar-link">根据id从树形结构中查找出对象</a></li><li><a href="/blog/guide/js/regular.html" class="sidebar-link">常用的正则表达式</a></li><li><a href="/blog/guide/js/idCard.html" class="sidebar-link">身份证号正则判断详解</a></li><li><a href="/blog/guide/js/dataType.html" class="sidebar-link">数据类型判断</a></li><li><a href="/blog/guide/js/endForEach.html" class="sidebar-link">强制结束forEach</a></li><li><a href="/blog/guide/js/clone.html" class="sidebar-link">深克隆浅克隆</a></li><li><a href="/blog/guide/js/valueOf.html" class="sidebar-link">Object.valueOf</a></li><li><a href="/blog/guide/js/task.html" class="sidebar-link">简易任务队列</a></li><li><a href="/blog/guide/js/openUrl.html" class="sidebar-link">输入url到页面呈现浏览器做了哪些</a></li><li><a href="/blog/guide/js/changeToRem.html" class="sidebar-link">自动转换 px 到 rem</a></li><li><a href="/blog/guide/js/changeToCM.html" class="sidebar-link">像素与长度单位cm的换算方法</a></li><li><a href="/blog/guide/js/method.html" class="sidebar-link">常用方法</a></li><li><a href="/blog/guide/js/getParams.html" class="sidebar-link">获取url中参数值的js方法</a></li><li><a href="/blog/guide/js/judgeVal.html" class="sidebar-link">快速判断数组中每个对象同一属性值是否相同（3种方法）</a></li><li><a href="/blog/guide/js/cache.html" class="sidebar-link">谈谈项目缓存</a></li><li><a href="/blog/guide/js/settings.html" class="sidebar-link">vsCode配置文件</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>JS基础</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">JS基础</h1> <div data-v-8a445198><!----> <!----> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>js</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="基础知识"><a href="#基础知识" class="header-anchor">#</a> 基础知识</h2> <p>本章将从最简单的讲起，循序渐进、由浅入深，力求清晰易懂地全面介绍 JS基础特性和语法。</p> <h3 id="关于js"><a href="#关于js" class="header-anchor">#</a> 关于js</h3> <p>JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。</p> <p>JavaScript 本身只能用来做一些数学和逻辑运算，不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以它只合适嵌入到更大型的应用程序环境，去调用宿主环境提供的底层 API。</p> <h3 id="js的宿主环境"><a href="#js的宿主环境" class="header-anchor">#</a> JS的宿主环境</h3> <p>目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。</p> <p>JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（一系列具有各种功能的对象比如Array、Date、Math等）。</p> <p>除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类。</p> <ul><li>浏览器控制类：操作浏览器</li> <li>DOM 类：操作网页的各种元素</li> <li>Web 类：实现互联网的各种功能</li></ul> <p>如果宿主环境是服务器，则会提供各种操作系统的 API，比如文件操作 API、网络通信 API等等。这些你都可以在 Node 环境中找到。</p> <h3 id="js的使用领域"><a href="#js的使用领域" class="header-anchor">#</a> JS的使用领域</h3> <p>JavaScript 的发明目的，就是作为浏览器的内置脚本语言，为网页开发者提供操控浏览器的能力。它是目前唯一一种通用的浏览器脚本语言，所有浏览器都支持。</p> <p>近年来，JavaScript 的使用范围，慢慢超越了浏览器，正在向通用的系统语言发展。</p> <ul><li>浏览器的平台化： 随着 HTML5 的出现，浏览器本身的功能越来越强，不再仅仅能浏览网页，而是越来越像一个平台，JavaScript 因此得以调用许多系统功能；</li> <li>Node 项目：用于开发服务器端的大型项目，网站的前后端都用 JavaScript 开发已经成为了现实；</li> <li>移动平台开发：Facebook 公司的 React Native 项目以及基于vue的weex让JS成为越来越多手机应用的开发语言;</li> <li>跨平台的桌面应用程序：Mozilla 的 Open Web Apps 项目、Google 的 Chrome App 项目、GitHub 的 Electron 项目、以及 TideSDK 项目，都可以用来编写运行于 Windows、Mac OS 和 Android 等多个桌面平台的程序，不依赖浏览器。</li></ul> <h3 id="基本语法"><a href="#基本语法" class="header-anchor">#</a> 基本语法</h3> <h4 id="语句"><a href="#语句" class="header-anchor">#</a> 语句</h4> <p>JavaScript 程序的执行单位为行，每一行就是一个语句(为了完成某种任务而进行的操作)，如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a = 1 + 3;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。</p> <p>1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。</p> <p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a = 1 + 3 ; var b = 'abc';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="变量"><a href="#变量" class="header-anchor">#</a> 变量</h4> <h5 id="变量的概念"><a href="#变量的概念" class="header-anchor">#</a> 变量的概念</h5> <p>变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a = 1;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。</p> <ul><li>JS 的变量名区分大小写，A和a是两个不同的变量;</li> <li>如果只是声明变量而没有赋值，则该变量的值是undefined;</li> <li>JS 是一种动态类型语言，变量的类型没有限制，可以随时更改类型;</li></ul> <p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。let不允许在相同作用域内，重复声明同一个变量。</p> <p>let实际上为 JavaScript 新增了块级作用域。</p> <p>const声明一个只读的常量。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p> <p>const的作用域与let命令相同：只在声明所在的块级作用域内有效</p> <h5 id="变量的提升"><a href="#变量的提升" class="header-anchor">#</a> 变量的提升</h5> <p>JS 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>console.log(a);
var a = 1;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>因为存在变量提升，真正运行的是下面的代码:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a;
console.log(a);
a = 1;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p> <p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p> <h5 id="暂时性死区"><a href="#暂时性死区" class="header-anchor">#</a> 暂时性死区</h5> <p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p> <p>在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p> <p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。</p> <p>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。</p> <h5 id="解构赋值"><a href="#解构赋值" class="header-anchor">#</a> 解构赋值</h5> <p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let [a, b, c] = [1, 2, 3];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p> <p>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p> <p>解构赋值允许指定默认值。</p> <p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p> <h4 id="标识符"><a href="#标识符" class="header-anchor">#</a> 标识符</h4> <p>标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。</p> <p>标识符命名规则如下：</p> <ul><li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。</li> <li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。</li></ul> <h4 id="注释"><a href="#注释" class="header-anchor">#</a> 注释</h4> <p>源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：一种是单行注释，用//起头；另一种是多行注释，放在/<em>和</em>/之间。</p> <p>此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以也被视为合法的单行注释。需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。</p> <h4 id="条件语句"><a href="#条件语句" class="header-anchor">#</a> 条件语句</h4> <p>JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。</p> <p>三元运算符 ? 可以被视为if...else...的简写形式，</p> <h4 id="循环语句"><a href="#循环语句" class="header-anchor">#</a> 循环语句</h4> <p>循环语句用于重复执行某个操作，它有多种形式：</p> <ul><li>While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</li> <li>for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。</li> <li>do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</li> <li>break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。</li></ul> <h4 id="标签"><a href="#标签" class="header-anchor">#</a> 标签</h4> <p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置。</p> <p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p> <p>标签通常与break语句和continue语句配合使用，跳出特定的循环。</p> <h2 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h2> <p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有七种：</p> <ul><li>数值（number）：整数和小数（比如1和3.14）</li> <li>字符串（string）：文本（比如Hello World）。</li> <li>布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）</li> <li>undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</li> <li>null：表示空值，即此处的值为空。</li> <li>对象（object）：各种值组成的集合。</li> <li>Symbol：通过Symbol函数生成，表示独一无二的值，用于防止对象属性名的冲突。</li></ul> <h3 id="确定值类型的方法"><a href="#确定值类型的方法" class="header-anchor">#</a> 确定值类型的方法</h3> <p>JavaScript 有三种方法，可以确定一个值到底是什么类型：</p> <ul><li>typeof运算符</li> <li>instanceof运算符</li> <li>Object.prototype.toString方法</li></ul> <h4 id="typeof-运算符"><a href="#typeof-运算符" class="header-anchor">#</a> typeof 运算符</h4> <p>typeof运算符可以返回一个值的数据类型：</p> <ul><li>数值、字符串、布尔值分别返回number、string、boolean。</li> <li>Symbol 类型 返回symbol</li> <li>对象返回object</li> <li>null返回object，历史原因造成的</li> <li>函数返回function；</li> <li>undefined返回undefined</li></ul> <h4 id="instanceof运算符"><a href="#instanceof运算符" class="header-anchor">#</a> instanceof运算符</h4> <p>instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p> <p>instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。</p> <p>由于instanceof检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回true。</p> <p>由于任意对象（除了null）都是Object的实例，所以instanceof运算符可以判断一个值是否为非null的对象。</p> <p>instanceof的原理是检查右边构造函数的prototype属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有null对象。</p> <p>注意，instanceof运算符只能用于对象，不适用原始类型的值。</p> <p>此外，对于undefined和null，instanceof运算符总是返回false。</p> <h4 id="object-prototype-tostring方法"><a href="#object-prototype-tostring方法" class="header-anchor">#</a> Object.prototype.toString方法</h4> <p>toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串，因此可以用来判断一个值的类型。
不同数据类型的Object.prototype.toString方法返回值如下：</p> <ul><li>数值：返回[object Number]。</li> <li>字符串：返回[object String]。</li> <li>布尔值：返回[object Boolean]。</li> <li>undefined：返回[object Undefined]。</li> <li>null：返回[object Null]。</li> <li>数组：返回[object Array]。</li> <li>arguments 对象：返回[object Arguments]。</li> <li>函数：返回[object Function]。</li> <li>Error 对象：返回[object Error]。</li> <li>Date 对象：返回[object Date]。</li> <li>RegExp 对象：返回[object RegExp]。</li> <li>其他对象：返回[object Object]。
这就是说，Object.prototype.toString可以看出一个值到底是什么类型。</li></ul> <p>利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var type = function (o){
  var s = Object.prototype.toString.call(o);
  return s.match(/\[object (.*?)\]/)[1].toLowerCase();
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="null-undefined"><a href="#null-undefined" class="header-anchor">#</a> null, undefined</h3> <p>null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。在if语句中，它们都会被自动转为false。</p> <p>谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有null，没有undefined！</p> <p>null是一个表示“空”的对象，转为数值时为0；undefined是一个表示&quot;此处无定义&quot;的原始值，转为数值时为NaN。</p> <h3 id="布尔值"><a href="#布尔值" class="header-anchor">#</a> 布尔值</h3> <p>布尔值代表“真”和“假”两个状态，往往用于程序流程的控制。“真”用关键字true表示，“假”用关键字false表示。</p> <p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。</p> <p>转换规则是除了下面六个值被转为false，其他值都视为true：</p> <ul><li>undefined</li> <li>null</li> <li>false</li> <li>0</li> <li>NaN</li> <li>&quot;&quot;或''（空字符串）</li></ul> <p>空数组（[]）和空对象（{}）对应的布尔值，都是true。</p> <h3 id="数值"><a href="#数值" class="header-anchor">#</a> 数值</h3> <p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。</p> <p>JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。</p> <p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p> <p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。</p> <p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。</p> <p>JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p> <p>+0或-0当作分母，返回的值是不相等的，因为除以正零得到+Infinity，除以负零得到-Infinity。</p> <p>NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p> <p>NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。</p> <p>NaN不等于任何值，包括它本身。NaN与任何数（包括它自己）的运算，得到的都是NaN。</p> <p>Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。</p> <p>Infinity与NaN比较，总是返回false。</p> <h4 id="parseint"><a href="#parseint" class="header-anchor">#</a> parseInt()</h4> <p>parseInt方法用于将字符串转为整数。parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。</p> <p>如果字符串头部有空格，空格会被自动去除。如果parseInt的参数不是字符串，则会先转为字符串再转换。</p> <p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p> <p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。</p> <p>对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p> <p>parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。</p> <p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。</p> <h4 id="parsefloat"><a href="#parsefloat" class="header-anchor">#</a> parseFloat()</h4> <p>parseFloat方法用于将一个字符串转为浮点数。</p> <p>parseFloat方法会自动过滤字符串前导的空格。</p> <p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p> <p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。</p> <p>parseFloat会将空字符串转为NaN。</p> <h4 id="isnan"><a href="#isnan" class="header-anchor">#</a> isNaN()</h4> <p>isNaN方法可以用来判断一个值是否为NaN。</p> <p>isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true。</p> <p>isNaN为true的值，有可能不是NaN，而是一个字符串。</p> <p>出于同样的原因，对于对象和数组，isNaN也返回true。</p> <p>但是，对于空数组和只有一个数值成员的数组，isNaN返回false。原因是这些数组能被Number函数转成数值。</p> <p>因此，使用isNaN之前，最好判断一下数据类型。</p> <p>判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。</p> <h4 id="isfinite"><a href="#isfinite" class="header-anchor">#</a> isFinite()</h4> <p>isFinite方法返回一个布尔值，表示某个值是否为正常的数值。</p> <p>除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。</p> <h3 id="字符串"><a href="#字符串" class="header-anchor">#</a> 字符串</h3> <p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p> <p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。</p> <p>由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号。</p> <p>反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p> <p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始），字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p> <p>每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。</p> <p>Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p> <h3 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h3> <p>对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p> <p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。</p> <p>如果键名是数值，会被自动转为字符串。</p> <p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p> <p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p> <p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p> <p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p> <p>如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</p> <p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</p> <p>查看一个对象本身的所有属性，可以使用Object.keys方法。</p> <p>delete命令用于删除对象的属性，删除成功后返回true。</p> <p>delete命令只能删除对象本身的属性，无法删除继承的属性。</p> <p>in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false</p> <p>可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。</p> <p>for...in循环用来遍历一个对象的全部属性。</p> <h3 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h3> <p>数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。</p> <p>任何类型的数据，都可以放入数组。</p> <p>本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。</p> <p>JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p> <p>对象有两种读取成员的方法：点结构（object.key）和方括号结构（object[key]）。但是，对于数值的键名，不能使用点结构。</p> <p>只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。</p> <p>清空数组的一个有效方法，就是将length属性设为0。</p> <p>由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。</p> <p>for...in不仅会遍历数组所有的数字键，还会遍历非数字键。所以，不推荐使用for...in遍历数组。</p> <h3 id="类数组"><a href="#类数组" class="header-anchor">#</a> 类数组</h3> <p>如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</p> <p>类似数组的对象”并不是数组，因为它们不具备数组特有的方法。</p> <p>典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。</p> <p>数组的slice方法可以将“类似数组的对象”变成真正的数组。</p> <h2 id="内置对象"><a href="#内置对象" class="header-anchor">#</a> 内置对象</h2> <h3 id="属性描述对象"><a href="#属性描述对象" class="header-anchor">#</a> 属性描述对象</h3> <p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等。</p> <p>这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p> <p>Object.getOwnPropertyDescriptor()方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。</p> <p>Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</p> <p>Object.defineProperty()方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象。</p> <p>Object.defineProperty方法接受三个参数，依次如下。</p> <ul><li>object：属性所在的对象</li> <li>propertyName：字符串，表示属性名</li> <li>attributesObject：属性描述对象</li></ul> <p>如果属性已经存在，Object.defineProperty()方法相当于更新该属性的属性描述对象。</p> <p>如果一次性定义或修改多个属性，可以使用Object.defineProperties()方法。</p> <p>如果一个属性的enumerable为false，下面三个操作不会取到该属性。</p> <ul><li>for..in循环</li> <li>Object.keys方法</li> <li>JSON.stringify方法</li></ul> <p>for...in循环包括继承的属性，Object.keys方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用Object.getOwnPropertyNames方法。</p> <p>除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。</p> <p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。</p> <h3 id="object-对象"><a href="#object-对象" class="header-anchor">#</a> Object 对象</h3> <p>JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。</p> <p>Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。</p> <p>Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。</p> <p>如果参数为空（或者为undefined和null），Object()返回一个空对象。</p> <p>如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例。</p> <p>如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。</p> <p>Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。</p> <p>Object构造函数的首要用途，是直接通过它来生成新对象。</p> <p>Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。</p> <p>Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。</p> <p>对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性。</p> <p>除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。</p> <p>Object实例对象的方法，主要有以下六个。</p> <ul><li>Object.prototype.valueOf()：返回当前对象对应的值。</li> <li>Object.prototype.toString()：返回当前对象对应的字符串形式。</li> <li>Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。</li> <li>Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li> <li>Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。</li> <li>Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。</li></ul> <p>数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。</p> <h3 id="包装对象"><a href="#包装对象" class="header-anchor">#</a> 包装对象</h3> <p>对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”（wrapper）。</p> <p>所谓“包装对象”，指的是与数值、字符串、布尔值分别相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</p> <p>包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。</p> <p>这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。</p> <p>valueOf()方法返回包装对象实例对应的原始类型的值。</p> <p>toString()方法返回对应的字符串形式。</p> <p>某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。</p> <h4 id="boolean-对象"><a href="#boolean-对象" class="header-anchor">#</a> Boolean 对象</h4> <p>Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。</p> <h4 id="number-对象"><a href="#number-对象" class="header-anchor">#</a> Number 对象</h4> <p>Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</p> <p>Number对象拥有以下一些静态属性（即直接定义在Number对象上的属性，而不是定义在实例上的属性）。</p> <ul><li>Number.POSITIVE_INFINITY：正的无限，指向Infinity。</li> <li>Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。</li> <li>Number.NaN：表示非数值，指向NaN。</li> <li>Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。</li> <li>Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。</li> <li>Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。</li></ul> <p>Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。</p> <p>toFixed()方法先将一个数转为指定位数的小数。</p> <p>toExponential方法用于将一个数转为科学计数法形式。</p> <p>Number.prototype.toPrecision()方法用于将一个数转为指定位数的有效数字。</p> <p>Number.prototype.toLocaleString()方法接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式。</p> <p>与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。</p> <h4 id="string-对象"><a href="#string-对象" class="header-anchor">#</a> String 对象</h4> <p>String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。</p> <p>String对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</p> <p>String.prototype.length 字符串实例的length属性返回字符串的长度。</p> <p>charAt方法返回指定位置的字符，参数是从0开始编号的位置。</p> <p>charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。</p> <p>concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</p> <p>slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p> <p>substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。</p> <p>substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。</p> <p>indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</p> <p>lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。</p> <p>trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p> <p>toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</p> <p>match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。</p> <p>search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</p> <p>replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。</p> <p>split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</p> <p>localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</p> <h3 id="array-对象"><a href="#array-对象" class="header-anchor">#</a> Array 对象</h3> <p>Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</p> <p>Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p> <p>Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。</p> <p>valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。</p> <p>toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。</p> <p>push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。</p> <p>pop方法用于删除数组的最后一个元素，并返回该元素。对空数组使用pop方法，不会报错，而是返回undefined。</p> <p>shift()方法用于删除数组的第一个元素，并返回该元素。shift()方法可以遍历并清空一个数组。</p> <p>unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。</p> <p>join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p> <p>concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</p> <p>reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</p> <p>slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。slice方法的一个重要应用，是将类似数组的对象转为真正的数组。</p> <p>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。</p> <p>sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。</p> <p>如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。</p> <p>map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回</p> <p>forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。</p> <p>filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</p> <p>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。</p> <p>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</p> <h3 id="json-对象"><a href="#json-对象" class="header-anchor">#</a> JSON 对象</h3> <p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。</p> <p>JSON 对值的类型和格式有严格的规定：</p> <ul><li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li> <li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。</li> <li>字符串必须使用双引号表示，不能使用单引号。</li> <li>对象的键名必须放在双引号里面。</li> <li>数组或对象最后一个成员的后面，不能加逗号。</li></ul> <p>JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：JSON.stringify()和JSON.parse()。</p> <h4 id="json-stringify"><a href="#json-stringify" class="header-anchor">#</a> JSON.stringify()</h4> <p>JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。</p> <p>注意，对于原始类型的字符串，转换结果会带双引号。</p> <p>如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤。</p> <p>如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。</p> <p>正则对象会被转成空对象。</p> <p>JSON.stringify方法会忽略对象的不可遍历的属性。</p> <p>JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。</p> <p>第二个参数还可以是一个函数，用来更改JSON.stringify的返回值。</p> <p>JSON.stringify还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</p> <p>如果参数对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。</p> <h4 id="json-parse"><a href="#json-parse" class="header-anchor">#</a> JSON.parse()</h4> <p>JSON.parse方法用于将 JSON 字符串转换成对应的值。</p> <p>如果传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错。</p> <p>为了处理解析错误，可以将JSON.parse方法放在try...catch代码块中。</p> <p>JSON.parse方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify方法类似。</p> <h3 id="set"><a href="#set" class="header-anchor">#</a> Set</h3> <p>它类似于数组，但是成员的值都是唯一的，没有重复的值。</p> <p>Set本身是一个构造函数，用来生成 Set 数据结构。</p> <p>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p> <p>Set 结构的实例有以下属性。</p> <ul><li>Set.prototype.constructor：构造函数，默认就是Set函数。</li> <li>Set.prototype.size：返回Set实例的成员总数。</li></ul> <p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p> <ul><li>Set.prototype.add(value)：添加某个值，返回 Set 结构本身。</li> <li>Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li> <li>Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。</li> <li>Set.prototype.clear()：清除所有成员，没有返回值。</li></ul> <p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p> <ul><li>Set.prototype.keys()：返回键名的遍历器</li> <li>Set.prototype.values()：返回键值的遍历器</li> <li>Set.prototype.entries()：返回键值对的遍历器</li> <li>Set.prototype.forEach()：使用回调函数遍历每个成员
Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</li></ul> <p>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</p> <p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。</p> <h3 id="weakset"><a href="#weakset" class="header-anchor">#</a> WeakSet</h3> <p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p> <p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p> <p>WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p> <p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p> <p>WeakSet 没有size属性，没有办法遍历它的成员。</p> <p>WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p> <p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p> <p>也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p> <p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p> <p>size属性返回 Map 结构的成员总数。</p> <p>Map.prototype.set(key, value)方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是当前的Map对象，因此可以采用链式写法。</p> <p>Map.prototype.get(key)方法读取key对应的键值，如果找不到key，返回undefined。</p> <p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p> <ul><li>Map.prototype.keys()：返回键名的遍历器。</li> <li>Map.prototype.values()：返回键值的遍历器。</li> <li>Map.prototype.entries()：返回所有成员的遍历器。</li> <li>Map.prototype.forEach()：遍历 Map 的所有成员。
需要特别注意的是，Map 的遍历顺序就是插入顺序。</li></ul> <h3 id="weakmap"><a href="#weakmap" class="header-anchor">#</a> WeakMap</h3> <p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。</p> <p>首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</p> <p>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。</p> <p>如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。WeakMap 的另一个用处是部署私有属性。</p> <p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p> <h2 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h2> <p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。</p> <p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。</p> <h3 id="函数的声明"><a href="#函数的声明" class="header-anchor">#</a> 函数的声明</h3> <p>JavaScript 有三种声明函数的方法。如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</p> <h4 id="function-命令"><a href="#function-命令" class="header-anchor">#</a> function 命令</h4> <p>function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面</p> <h4 id="函数表达式"><a href="#函数表达式" class="header-anchor">#</a> 函数表达式</h4> <p>除了用function命令声明函数，还可以采用变量赋值的写法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var print = function(s) {
  console.log(s);
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。</p> <p>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p> <p>加上函数名的写法用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。</p> <h4 id="function-构造函数"><a href="#function-构造函数" class="header-anchor">#</a> Function 构造函数</h4> <p>第三种声明函数的方式是Function构造函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var add = new Function(
  'x',
  'y',
  'return x + y'
);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。</p> <h3 id="圆括号运算符-return-语句和递归"><a href="#圆括号运算符-return-语句和递归" class="header-anchor">#</a> 圆括号运算符，return 语句和递归</h3> <p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。</p> <p>函数体内部的return语句，表示返回。JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。</p> <p>函数可以调用自身，这就是递归（recursion）。</p> <h3 id="函数名的提升"><a href="#函数名的提升" class="header-anchor">#</a> 函数名的提升</h3> <p>JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。</p> <p>但是，如果采用赋值语句定义函数，JavaScript 就会报错。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>f();
var f = function (){};
// TypeError: undefined is not a function
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="header-anchor">#</a> 函数的属性和方法</h3> <h4 id="name-属性"><a href="#name-属性" class="header-anchor">#</a> name 属性</h4> <p>name属性的一个用处，就是获取参数函数的名字。</p> <p>函数的name属性返回函数的名字，如果是通过变量赋值定义的函数，那么name属性返回变量名。</p> <p>但如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。</p> <h4 id="length-属性"><a href="#length-属性" class="header-anchor">#</a> length 属性</h4> <p>函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</p> <p>length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）。</p> <h4 id="tostring"><a href="#tostring" class="header-anchor">#</a> toString()</h4> <p>函数的toString方法返回一个字符串，内容是函数的源码。</p> <p>对于那些原生的函数，toString()方法返回function (){[native code]}</p> <h3 id="函数作用域"><a href="#函数作用域" class="header-anchor">#</a> 函数作用域</h3> <p>作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域。</p> <p>对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。</p> <p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。</p> <p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</p> <p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p> <p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p> <h3 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h3> <p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</p> <p>函数参数不是必需的，JavaScript 允许省略参数。函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。</p> <p>没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。</p> <p>数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</p> <p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</p> <p>如果有同名的参数，则取最后出现的那个值。</p> <h3 id="arguments-对象"><a href="#arguments-对象" class="header-anchor">#</a> arguments 对象</h3> <p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。</p> <p>arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p> <p>严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数。</p> <p>arguments对象带有一个callee属性，返回它所对应的原函数。可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p> <h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <p>闭包可以看作是函数内部作用域的一个接口。闭包的另一个用处，是封装对象的私有属性和私有方法。</p> <p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function f1() {
  var n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}

var result = f1();
result();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>JavaScript 语言特有的&quot;链式作用域&quot;结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p> <p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p> <p>闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p> <p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</p> <p>外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p> <h3 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="header-anchor">#</a> 立即调用的函数表达式</h3> <p>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。</p> <p>为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。</p> <p>解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>(function(){ /* code */ }());
// 或者
(function(){ /* code */ })();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。</p> <p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p> <h2 id="原型与继承"><a href="#原型与继承" class="header-anchor">#</a> 原型与继承</h2> <h3 id="原型对象"><a href="#原型对象" class="header-anchor">#</a> 原型对象</h3> <p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</p> <p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p> <p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。</p> <p>JavaScript 规定，每个函数都有一个prototype属性，指向一个对象。对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。</p> <p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。</p> <p>当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。</p> <h4 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h4> <p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型</p> <p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。</p> <p>而Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。</p> <p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。</p> <p>如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p> <p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p> <h4 id="constructor-属性"><a href="#constructor-属性" class="header-anchor">#</a> constructor 属性</h4> <p>prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。</p> <p>constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p> <p>constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。</p> <p>所以，修改原型对象时，一般要同时修改constructor属性的指向。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 坏的写法
C.prototype = {
  method1: function (...) { ... },
  // ...
};

// 好的写法
C.prototype = {
  constructor: C,
  method1: function (...) { ... },
  // ...
};

// 更好的写法
C.prototype.method1 = function (...) { ... };
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h3> <p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Sub(value) {
  Super.call(this);
  this.prop = value;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Sub是子类的构造函数，this是子类的实例。在实例上调用父类的构造函数Super，就会让子类实例具有父类实例的属性。</p> <p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Sub.prototype = Object.create(Super.prototype);
Sub.prototype.constructor = Sub;
Sub.prototype.method = '...';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面代码中，Sub.prototype是子类的原型，要将它赋值为Object.create(Super.prototype)，而不是直接等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype一起修改掉。</p> <p>另外一种写法是Sub.prototype等于一个父类实例:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Sub.prototype = new Super();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Shape() {
  this.x = 0;
  this.y = 0;
}

Shape.prototype.move = function (x, y) {
  this.x += x;
  this.y += y;
  console.info('Shape moved.');
};

// 第一步，子类继承父类的实例
function Rectangle() {
  Shape.call(this); // 调用父类构造函数
}
// 另一种写法
function Rectangle() {
  this.base = Shape;
  this.base();
}

// 第二步，子类继承父类的原型
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="多重继承"><a href="#多重继承" class="header-anchor">#</a> 多重继承</h3> <p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function M1() {
  this.hello = 'hello';
}

function M2() {
  this.world = 'world';
}

function S() {
  M1.call(this);
  M2.call(this);
}

// 继承 M1
S.prototype = Object.create(M1.prototype);
// 继承链上加入 M2
Object.assign(S.prototype, M2.prototype);

// 指定构造函数
S.prototype.constructor = S;

var s = new S();
s.hello // 'hello'
s.world // 'world'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="class-的继承"><a href="#class-的继承" class="header-anchor">#</a> Class 的继承</h3> <p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p> <p>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return '(' + this.x + ', ' + this.y + ')';
};

var p = new Point(1, 2);
// ES6 的class改写
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>ES6 的类，完全可以看作构造函数的另一种写法。</p> <p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Point { /* ... */ }

class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p> <p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p> <p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。</p> <p>super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p> <p>第一种情况，super作为函数调用时，代表父类的构造函数；第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p> <p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构</p> <p>ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。</p> <p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。</p> <p>ES6 可以自定义原生数据结构（比如Array、String等）的子类，这是 ES5 无法做到的。extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。</p> <h2 id="异步操作"><a href="#异步操作" class="header-anchor">#</a> 异步操作</h2> <p>JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。</p> <p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。</p> <p>JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p> <h3 id="基础概念"><a href="#基础概念" class="header-anchor">#</a> 基础概念</h3> <h4 id="同步和异步"><a href="#同步和异步" class="header-anchor">#</a> 同步和异步</h4> <p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p> <p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p> <p>所谓&quot;异步&quot;，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段</p> <p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。</p> <h4 id="任务队列和事件循环"><a href="#任务队列和事件循环" class="header-anchor">#</a> 任务队列和事件循环</h4> <p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。</p> <p>主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。</p> <p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。</p> <p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。</p> <h4 id="异步操作的模式"><a href="#异步操作的模式" class="header-anchor">#</a> 异步操作的模式</h4> <p>回调函数是异步操作最基本的方法，</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function f1(callback) {
  // ...
  callback();
}

function f2() {
  // ...
}

f1(f2);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p> <p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p> <p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p> <p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。</p> <h3 id="promise-对象"><a href="#promise-对象" class="header-anchor">#</a> Promise 对象</h3> <p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p> <p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p> <p>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 传统写法
step1(function (value1) {
  step2(value1, function(value2) {
    step3(value2, function(value3) {
      step4(value3, function(value4) {
        // ...
      });
    });
  });
});

// Promise 的写法
(new Promise(step1))
  .then(step2)
  .then(step3)
  .then(step4);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="promise-对象的状态"><a href="#promise-对象的状态" class="header-anchor">#</a> Promise 对象的状态</h4> <p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p> <ul><li>异步操作未完成（pending）</li> <li>异步操作成功（fulfilled）</li> <li>异步操作失败（rejected）
上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。</li></ul> <p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p> <p>因此，Promise 的最终结果只有两种。</p> <ul><li>异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。</li> <li>异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。</li></ul> <h4 id="promise-构造函数"><a href="#promise-构造函数" class="header-anchor">#</a> Promise 构造函数</h4> <p>JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var promise = new Promise(function (resolve, reject) {
  // ...

  if (/* 异步操作成功 */){
    resolve(value);
  } else { /* 异步操作失败 */
    reject(new Error());
  }
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上面代码中，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p> <p>resolve函数的作用是，将Promise实例的状态从“未完成”变为“成功”（即从pending变为fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</p> <p>reject函数的作用是，将Promise实例的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p> <h4 id="then方法"><a href="#then方法" class="header-anchor">#</a> then方法</h4> <p>Promise 实例的then方法，用来添加回调函数。</p> <p>then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。</p> <p>Promise 的用法，简单说就是一句话：使用then方法添加回调函数。</p> <p>Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p> <p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p> <p>Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p> <h3 id="generator-函数"><a href="#generator-函数" class="header-anchor">#</a> Generator 函数</h3> <p>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。</p> <p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function* gen(x) {
  var y = yield x + 2;
  return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。</p> <p>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p> <p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p> <h3 id="async-函数"><a href="#async-函数" class="header-anchor">#</a> async 函数</h3> <p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p> <p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p> <p>async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p> <p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p> <p>async函数对 Generator 函数的改进，体现在以下四点。</p> <ul><li>内置执行器: Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li> <li>更好的语义: async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li> <li>更广的适用性: co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li> <li>返回值是 Promise: async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</li></ul> <p>async函数的语法规则总体上比较简单，难点是错误处理机制。</p> <p>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p> <p>根据语法规格，await命令只能出现在 async 函数内部，否则都会报错。</p> <h2 id="正则表达式"><a href="#正则表达式" class="header-anchor">#</a> 正则表达式</h2> <p>正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。</p> <p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。另一种是使用RegExp构造函数。</p> <p>它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p> <h3 id="匹配规则"><a href="#匹配规则" class="header-anchor">#</a> 匹配规则</h3> <p>正则表达式的规则很复杂。</p> <h4 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="header-anchor">#</a> 字面量字符和元字符</h4> <p>大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。</p> <p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。</p> <ul><li>点字符（.) 匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。注意，对于码点大于0xFFFF字符，点字符不能正确匹配，会认为这是两个字符。</li> <li>位置字符：位置字符用来提示字符所处的位置，主要有两个字符：^ 表示字符串的开始位置，$ 表示字符串的结束位置</li> <li>选择符（|）：竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。</li> <li>转义符\ ：正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</li> <li>特殊字符：对一些不能打印的特殊字符，提供了表达方法：\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。[\b] 匹配退格键(U+0008)，不要与\b混淆。\n 匹配换行键。\r 匹配回车键。</li> <li>字符类：字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。</li> <li>脱字符（^）果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。</li> <li>连字符（-）对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。</li></ul> <h4 id="预定义模式"><a href="#预定义模式" class="header-anchor">#</a> 预定义模式</h4> <p>预定义模式指的是某些常见模式的简写方式。</p> <ul><li>\d 匹配0-9之间的任一数字，相当于[0-9]。</li> <li>\D 匹配所有0-9以外的字符，相当于[^0-9]。</li> <li>\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</li> <li>\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。</li> <li>\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。</li> <li>\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。</li> <li>\b 匹配词的边界。</li> <li>\B 匹配非词边界，即在词的内部。</li></ul> <p>通常，正则表达式遇到换行符（\n）就会停止匹配。</p> <h4 id="重复类"><a href="#重复类" class="header-anchor">#</a> 重复类</h4> <p>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。</p> <h4 id="量词符"><a href="#量词符" class="header-anchor">#</a> 量词符</h4> <p>量词符用来设定某个模式出现的次数。</p> <ul><li>? 问号表示某个模式出现0次或1次，等同于{0, 1}。</li> <li><ul><li>星号表示某个模式出现0次或多次，等同于{0,}。</li></ul></li> <li><ul><li>加号表示某个模式出现1次或多次，等同于{1,}。</li></ul></li></ul> <h3 id="修饰符"><a href="#修饰符" class="header-anchor">#</a> 修饰符</h3> <p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p> <p>修饰符可以单个使用，也可以多个一起使用。</p> <h4 id="g-修饰符"><a href="#g-修饰符" class="header-anchor">#</a> g 修饰符</h4> <p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p> <p>正则模式含有g修饰符，每次都是从上一次匹配成功处，开始向后匹配。</p> <h4 id="i-修饰符"><a href="#i-修饰符" class="header-anchor">#</a> i 修饰符</h4> <p>默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignoreCase）。</p> <h4 id="m-修饰符"><a href="#m-修饰符" class="header-anchor">#</a> m 修饰符</h4> <p>m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。</p> <h3 id="实例属性"><a href="#实例属性" class="header-anchor">#</a> 实例属性</h3> <p>正则对象的实例属性分成两类。</p> <p>一类是修饰符相关，用于了解设置了什么修饰符:</p> <ul><li>RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符。</li> <li>RegExp.prototype.global：返回一个布尔值，表示是否设置了g修饰符。</li> <li>RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m修饰符。</li> <li>RegExp.prototype.flags：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。
上面四个属性都是只读的。</li></ul> <p>另一类是与修饰符无关的属性，主要是下面两个。</p> <ul><li>RegExp.prototype.lastIndex：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。</li> <li>RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li></ul> <h3 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h3> <p>正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</p> <p>如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。</p> <p>lastIndex属性只对同一个正则表达式有效，所以下面这样写是错误的:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var count = 0;
while (/a/g.test('babaa')) count++;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面代码会导致无限循环，因为while循环的每次匹配条件都是一个新的正则表达式，导致lastIndex属性总是等于0。</p> <p>如果正则模式是一个空字符串，则匹配所有字符串。</p> <p>正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。</p> <p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。</p> <p>exec方法的返回数组还包含以下两个属性：</p> <ul><li>input：整个原字符串。</li> <li>index：整个模式匹配成功的开始位置（从0开始计数）。</li></ul> <p>如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p> <p>正则实例对象的lastIndex属性不仅可读，还可写。设置了g修饰符的时候，只要手动设置了lastIndex的值，就会从指定位置开始匹配。</p> <p>字符串的实例方法之中，有4种与正则表达式有关。</p> <ul><li>String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。</li> <li>String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</li> <li>String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。</li> <li>String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li></ul> <h2 id="proxy和reflect"><a href="#proxy和reflect" class="header-anchor">#</a> Proxy和Reflect</h2> <p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p> <p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p> <p>Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p> <h3 id="用法"><a href="#用法" class="header-anchor">#</a> 用法</h3> <p>Proxy 对象的所有用法，都是下面这种形式：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const proxy = new Proxy(target, handler);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>不同的只是handler参数的写法，其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p> <p>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p> <p>如果handler没有设置任何拦截，那就等同于直接通向原对象。</p> <h3 id="支持的拦截操作"><a href="#支持的拦截操作" class="header-anchor">#</a> 支持的拦截操作</h3> <p>一共 13 种:</p> <ul><li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。</li> <li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。</li> <li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li> <li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li> <li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、- - Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li> <li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li> <li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li> <li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li> <li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li> <li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li> <li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li> <li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。</li> <li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。</li></ul> <h3 id="reflect"><a href="#reflect" class="header-anchor">#</a> Reflect</h3> <p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API，Reflect对象的设计目的有这样几个：</p> <ul><li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</li> <li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li> <li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li> <li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</li></ul> <h2 id="函数作用域和块级作用域"><a href="#函数作用域和块级作用域" class="header-anchor">#</a> 函数作用域和块级作用域</h2> <h3 id="_1-1-函数作用域"><a href="#_1-1-函数作用域" class="header-anchor">#</a> 1.1  函数作用域</h3> <p>我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。</p> <blockquote><p>区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。（诀窍：左声明右表达式）</p></blockquote> <h4 id="_1-1-1-匿名和具名"><a href="#_1-1-1-匿名和具名" class="header-anchor">#</a> 1.1.1  匿名和具名</h4> <p>对于函数表达式你最熟悉的场景可能就是回调参数了，比如:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;I waited 1 second!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>匿名函数表达式书写起来简单快捷，但是也有缺点：</p> <ul><li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难；</li> <li>如果没有函数名，当函数需要引用自身时只能使用已经过期的<code>arguments.callee</code>引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li></ul> <h4 id="_1-1-2-立即执行函数表达式-iife"><a href="#_1-1-2-立即执行函数表达式-iife" class="header-anchor">#</a> 1.1.2 立即执行函数表达式（IIFE）</h4> <p>由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 ( ) 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表 达式，第二个 ( ) 执行了这个函数。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。把window当作参数传递进去，可以实现两个IIFE表达式互相访问了。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">IIFE</span><span class="token punctuation">(</span> <span class="token parameter">global</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3 </span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> global<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span> window <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_2-1-块作用域"><a href="#_2-1-块作用域" class="header-anchor">#</a> 2.1  块作用域</h3> <blockquote><p>至少从 ES3 发布以来，JavaScript 中就有了块作用域，而 with 和 catch 分句就是块作用域的两个小例子。但随着 ES6 中引入了 let，我们的代码终于有了创建完整、不受约束的块作用域的能力，块作用域在功能上和代码风格上都拥有很多激动人心的新特性。除JavaScript外的很多编程语言都支持块作用域，我们在for循环的头部直接定义了变量i，通常是因为只想在for循环内部的上下文中使用i，而忽略了i会被绑定在外部作用域(函数或全局)中的事实。</p></blockquote> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>为什么要把一个只在 for 循环内部使用(至少是应该只在内部使用)的变量 i 污染到整个
函数作用域中呢？变量 i 的块作用域(如果存在的话)将使得其只能在 for 循环内部使用，如果在函数中其他地方使用会导致错误。这对保证变量不会被混乱地复用及提升代码的可维护性都有很大帮助。这就是块作用域的用处，变量的声明应该距离使用的地方越近越好，并最大限度地本地化。另外一个例子：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> bar <span class="token operator">=</span> foo <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
  bar <span class="token operator">=</span> <span class="token function">something</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。</p> <h4 id="_2-1-1-with"><a href="#_2-1-1-with" class="header-anchor">#</a> 2.1.1  with</h4> <p>它是块作用域的一 个例子(块作用域的一种形式)，用 with 从对象中创建出的作用域仅在 with 声明中而非外 部作用域中有效。</p> <h4 id="_2-1-2-try-catch"><a href="#_2-1-2-try-catch" class="header-anchor">#</a> 2.1.2  try/catch</h4> <p>非常少有人会注意到 JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作
用域，其中声明的变量仅在 catch 内部有效。
例如:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">undefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行一个非法操作来强制制造一个异常</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 能够正常执行! </span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError: err not found</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_2-1-3-let"><a href="#_2-1-3-let" class="header-anchor">#</a> 2.1.3  let</h4> <p>let 关键字可以将变量绑定到所在的任意作用域中(通常是 { .. } 内部)。换句话说，let为其声明的变量隐式地了所在的块作用域。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> bar <span class="token operator">=</span> foo <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
  bar <span class="token operator">=</span> <span class="token function">something</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>只要声明是有效的，在声明中的任意位置都可以使用<code>{ .. }</code>括号来为 let 创建一个用于绑 定的块。但是使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不
“存在”。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">// ReferenceError bar is not defined</span>
  <span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>垃圾收集，另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。</li> <li>let循环，一个 let 可以发挥优势的典型例子就是之前讨论的 for 循环。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环 的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。
下面通过另一种方式来说明每次迭代时进行重新绑定的行为：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token keyword">let</span> j<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 每个迭代重新绑定！</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_2-1-4-const"><a href="#_2-1-4-const" class="header-anchor">#</a> 2.1.4  const</h4> <p>除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的 (常量)。const 声明一个只读的常量。一旦声明，常量的值就不会改变。这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p> <ul><li>const命令跟let命令一样不存在变量提升、具有块级作用域、存在暂时性死区。</li> <li>const 命令实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
<span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cannot access 'foo' before initializatio</span>
  <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  foo<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'james9527'</span><span class="token punctuation">;</span>
  foo<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//james9527</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//18</span>
  foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">//TypeError: Assignment to constant variable.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="_2-1-5-块作用域的替代方案"><a href="#_2-1-5-块作用域的替代方案" class="header-anchor">#</a> 2.1.5  块作用域的替代方案</h4> <p>在从 ES6 之前的环境向 ES6 过渡时，使用代码转换工具来对 ES6 代码进行处理，生成兼容 ES5 的代码。</p> <ul><li>Traceur
Google 维护着一个名为 Traceur 的项目，该项目正是用来将 ES6 代码转换成兼容 ES6 之前 的环境(大部分是 ES5，但不是全部)。TC39 委员会依赖这个工具(也有其他工具)来测 试他们指定的语义化相关的功能。Traceur 会将我们的代码片段转换成什么样子？你能猜到的~</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
 <span class="token keyword">try</span> <span class="token punctuation">{</span>
   <span class="token keyword">throw</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>通过使用这样的工具，我们就可以在使用块作用域时无需考虑目标平台是否是 ES6 环境， 因为 try/catch 从 ES3 开始就存在了(并且一直是这样工作的)。</p> <ul><li>隐式和显式作用域（let作用域或let声明）</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// ReferenceError</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-1-小结"><a href="#_3-1-小结" class="header-anchor">#</a> 3.1  小结</h3> <ul><li>函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会
在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，
也可以属于某个代码块(通常指<code>{ .. }</code>内部)。</li> <li>从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。</li> <li>在 ES6 中引入了 let 关键字(var 关键字的表亲)，用来在任意代码块中声明变量。if (..) { let a = 2; } 会声明一个劫持了 if 的<code>{ .. }</code>块的变量，并且将变量添加到这个块 中。</li> <li>IIFE 和 try/catch 并不是完全等价的，因为如果将一段代码中的任意一部分拿出来 用函数进行包裹，会改变这段代码的含义，其中的 this、return、break 和 contine 都会 发生变化。IIFE 并不是一个普适的解决方案，它只适合在某些情况下进行手动操作。最后问题就变成了：你是否想要块作用域？如果你想要，这些工具就可以帮助你。如果不想要，继续使用var来写代码就好了！</li></ul></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">3/23/2023, 15:50:06</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/guide/js/array.html">
          数组常用方法（一）
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blog/guide/js/basic.html#基础知识" class="sidebar-link reco-side-基础知识" data-v-b57cc07c>基础知识</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#关于js" class="sidebar-link reco-side-关于js" data-v-b57cc07c>关于js</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#js的宿主环境" class="sidebar-link reco-side-js的宿主环境" data-v-b57cc07c>JS的宿主环境</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#js的使用领域" class="sidebar-link reco-side-js的使用领域" data-v-b57cc07c>JS的使用领域</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#基本语法" class="sidebar-link reco-side-基本语法" data-v-b57cc07c>基本语法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/guide/js/basic.html#数据类型" class="sidebar-link reco-side-数据类型" data-v-b57cc07c>数据类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#确定值类型的方法" class="sidebar-link reco-side-确定值类型的方法" data-v-b57cc07c>确定值类型的方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#null-undefined" class="sidebar-link reco-side-null-undefined" data-v-b57cc07c>null, undefined</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#布尔值" class="sidebar-link reco-side-布尔值" data-v-b57cc07c>布尔值</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#数值" class="sidebar-link reco-side-数值" data-v-b57cc07c>数值</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#字符串" class="sidebar-link reco-side-字符串" data-v-b57cc07c>字符串</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#对象" class="sidebar-link reco-side-对象" data-v-b57cc07c>对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#数组" class="sidebar-link reco-side-数组" data-v-b57cc07c>数组</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#类数组" class="sidebar-link reco-side-类数组" data-v-b57cc07c>类数组</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/guide/js/basic.html#内置对象" class="sidebar-link reco-side-内置对象" data-v-b57cc07c>内置对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#属性描述对象" class="sidebar-link reco-side-属性描述对象" data-v-b57cc07c>属性描述对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#object-对象" class="sidebar-link reco-side-object-对象" data-v-b57cc07c>Object 对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#包装对象" class="sidebar-link reco-side-包装对象" data-v-b57cc07c>包装对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#array-对象" class="sidebar-link reco-side-array-对象" data-v-b57cc07c>Array 对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#json-对象" class="sidebar-link reco-side-json-对象" data-v-b57cc07c>JSON 对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#set" class="sidebar-link reco-side-set" data-v-b57cc07c>Set</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#weakset" class="sidebar-link reco-side-weakset" data-v-b57cc07c>WeakSet</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#map" class="sidebar-link reco-side-map" data-v-b57cc07c>Map</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#weakmap" class="sidebar-link reco-side-weakmap" data-v-b57cc07c>WeakMap</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/guide/js/basic.html#函数" class="sidebar-link reco-side-函数" data-v-b57cc07c>函数</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#函数的声明" class="sidebar-link reco-side-函数的声明" data-v-b57cc07c>函数的声明</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#圆括号运算符-return-语句和递归" class="sidebar-link reco-side-圆括号运算符-return-语句和递归" data-v-b57cc07c>圆括号运算符，return 语句和递归</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#函数名的提升" class="sidebar-link reco-side-函数名的提升" data-v-b57cc07c>函数名的提升</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#函数的属性和方法" class="sidebar-link reco-side-函数的属性和方法" data-v-b57cc07c>函数的属性和方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#函数作用域" class="sidebar-link reco-side-函数作用域" data-v-b57cc07c>函数作用域</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#参数" class="sidebar-link reco-side-参数" data-v-b57cc07c>参数</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#arguments-对象" class="sidebar-link reco-side-arguments-对象" data-v-b57cc07c>arguments 对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#闭包" class="sidebar-link reco-side-闭包" data-v-b57cc07c>闭包</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#立即调用的函数表达式" class="sidebar-link reco-side-立即调用的函数表达式" data-v-b57cc07c>立即调用的函数表达式</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/guide/js/basic.html#原型与继承" class="sidebar-link reco-side-原型与继承" data-v-b57cc07c>原型与继承</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#原型对象" class="sidebar-link reco-side-原型对象" data-v-b57cc07c>原型对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#继承" class="sidebar-link reco-side-继承" data-v-b57cc07c>继承</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#多重继承" class="sidebar-link reco-side-多重继承" data-v-b57cc07c>多重继承</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#class-的继承" class="sidebar-link reco-side-class-的继承" data-v-b57cc07c>Class 的继承</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/guide/js/basic.html#异步操作" class="sidebar-link reco-side-异步操作" data-v-b57cc07c>异步操作</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#基础概念" class="sidebar-link reco-side-基础概念" data-v-b57cc07c>基础概念</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#promise-对象" class="sidebar-link reco-side-promise-对象" data-v-b57cc07c>Promise 对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#generator-函数" class="sidebar-link reco-side-generator-函数" data-v-b57cc07c>Generator 函数</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#async-函数" class="sidebar-link reco-side-async-函数" data-v-b57cc07c>async 函数</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/guide/js/basic.html#正则表达式" class="sidebar-link reco-side-正则表达式" data-v-b57cc07c>正则表达式</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#匹配规则" class="sidebar-link reco-side-匹配规则" data-v-b57cc07c>匹配规则</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#修饰符" class="sidebar-link reco-side-修饰符" data-v-b57cc07c>修饰符</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#实例属性" class="sidebar-link reco-side-实例属性" data-v-b57cc07c>实例属性</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#实例方法" class="sidebar-link reco-side-实例方法" data-v-b57cc07c>实例方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/guide/js/basic.html#proxy和reflect" class="sidebar-link reco-side-proxy和reflect" data-v-b57cc07c>Proxy和Reflect</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#用法" class="sidebar-link reco-side-用法" data-v-b57cc07c>用法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#支持的拦截操作" class="sidebar-link reco-side-支持的拦截操作" data-v-b57cc07c>支持的拦截操作</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#reflect" class="sidebar-link reco-side-reflect" data-v-b57cc07c>Reflect</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/guide/js/basic.html#函数作用域和块级作用域" class="sidebar-link reco-side-函数作用域和块级作用域" data-v-b57cc07c>函数作用域和块级作用域</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#_1-1-函数作用域" class="sidebar-link reco-side-_1-1-函数作用域" data-v-b57cc07c>1.1  函数作用域</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#_2-1-块作用域" class="sidebar-link reco-side-_2-1-块作用域" data-v-b57cc07c>2.1  块作用域</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/guide/js/basic.html#_3-1-小结" class="sidebar-link reco-side-_3-1-小结" data-v-b57cc07c>3.1  小结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.7d9bf940.js" defer></script><script src="/blog/assets/js/3.ce84a6f3.js" defer></script><script src="/blog/assets/js/1.22a35a13.js" defer></script><script src="/blog/assets/js/30.4cb7387c.js" defer></script>
  </body>
</html>
