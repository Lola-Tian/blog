(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{474:function(e,t,n){e.exports=n.p+"assets/img/1.9d0ee8f6.png"},475:function(e,t,n){e.exports=n.p+"assets/img/2.67b5a231.jpg"},476:function(e,t,n){e.exports=n.p+"assets/img/3.ced4519f.jpg"},477:function(e,t,n){e.exports=n.p+"assets/img/4.a8df1480.jpg"},478:function(e,t,n){e.exports=n.p+"assets/img/5.330fc35d.jpg"},479:function(e,t,n){e.exports=n.p+"assets/img/6.6510418d.jpg"},480:function(e,t,n){e.exports=n.p+"assets/img/7.709ec6df.jpg"},481:function(e,t,n){e.exports=n.p+"assets/img/8.4bcc6ec8.jpg"},482:function(e,t,n){e.exports=n.p+"assets/img/9.927a8307.jpg"},483:function(e,t,n){e.exports=n.p+"assets/img/10.c2124b74.jpg"},484:function(e,t,n){e.exports=n.p+"assets/img/11.619d852e.jpg"},485:function(e,t,n){e.exports=n.p+"assets/img/12.80bd27ad.jpg"},541:function(e,t,n){"use strict";n.r(t);var a=n(2),s=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"相比于vue2-0-vue3-0做了那些优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相比于vue2-0-vue3-0做了那些优化"}},[e._v("#")]),e._v(" 相比于Vue2.0,Vue3.0做了那些优化?")]),e._v(" "),t("p",[e._v("1.diff方法优化:")]),e._v(" "),t("p",[e._v("(1)Vue2.0中虚拟dom是进行全量对比")]),e._v(" "),t("p",[e._v("如下图:")]),e._v(" "),t("img",{attrs:{src:n(474)}}),e._v(" "),t("p",[e._v("(2)Vue3.0中新增了静态标记(PatchFlag),在与上次虚拟dom进行对比时,只对比带有patch falg的节点\n并且可以通过flag的x信息得知当前节点要对比的具体内容")]),e._v(" "),t("p",[e._v("如下图:")]),e._v(" "),t("img",{attrs:{src:n(475)}}),e._v(" "),t("h2",{attrs:{id:"用diff算法进行vode对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用diff算法进行vode对比"}},[e._v("#")]),e._v(" 用diff算法进行vode对比")]),e._v(" "),t("p",[e._v("在vue update过程中在遍历子代vnode的过程中，会用不同的patch方法来patch新老vnode，如果找到对应的 newVnode 和 oldVnode,就可以复用利用里面的真实dom节点。避免了重复创建元素带来的性能开销。毕竟浏览器创造真实的dom，操纵真实的dom，性能代价是昂贵的。")]),e._v(" "),t("p",[e._v("patch过程中，如果面对当前vnode存在有很多chidren的情况,那么需要分别遍历patch新的children Vnode和老的 children vnode。")]),e._v(" "),t("p",[e._v("刚说到,哎,我怎么知道这个vnode是newVnode还是oldVnode呢?那下面我们来看一下,")]),e._v(" "),t("p",[e._v("vue3.0中 在patchChildren方法中有这么一段源码:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("if (patchFlag > 0) {\n    if (patchFlag & PatchFlags.KEYED_FRAGMENT) { \n        /* 对于存在key的情况用于diff算法 */\n        patchKeyedChildren(\n        c1 as VNode[],\n        c2 as VNodeArrayChildren,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        optimized\n        )\n        return\n    } else if (patchFlag & PatchFlags.UNKEYED_FRAGMENT) {\n        /* 对于不存在key的情况,直接patch  */\n        patchUnkeyedChildren( \n        c1 as VNode[],\n        c2 as VNodeArrayChildren,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        optimized\n        )\n        return\n    }\n    }\n")])])]),t("p",[e._v("patchChildren根据是否存在key进行真正的diff或者直接patch。")]),e._v(" "),t("h2",{attrs:{id:"diff算法作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff算法作用"}},[e._v("#")]),e._v(" diff算法作用？")]),e._v(" "),t("p",[e._v("通过前言我们知道，存在这children的情况的vnode，需要通过patchChildren遍历children依次进行patch操作，如果在patch期间，再发现存在vnode情况，那么会递归的方式依次向下patch，那么找到与新的vnode对应的vnode显的如此重要。")]),e._v(" "),t("p",[e._v("我们用两幅图来向大家展示vnode变化。")]),e._v(" "),t("img",{attrs:{src:n(476)}}),e._v(" "),t("img",{attrs:{src:n(477)}}),e._v(" "),t("p",[e._v("如上两幅图表示在一次更新中新老dom树变化情况。")]),e._v(" "),t("p",[e._v("假设不存在diff算法，依次按照先后顺序patch会发生什么。")]),e._v(" "),t("p",[e._v("如果不存在diff算法，而是直接patchchildren 就会出现如下图的逻辑。")]),e._v(" "),t("img",{attrs:{src:n(478)}}),e._v(" "),t("p",[e._v("第一次patchChidren")]),e._v(" "),t("img",{attrs:{src:n(479)}}),e._v(" "),t("p",[e._v("第二次patchChidren")]),e._v(" "),t("img",{attrs:{src:n(480)}}),e._v(" "),t("p",[e._v("第三次patchChidren")]),e._v(" "),t("img",{attrs:{src:n(481)}}),e._v(" "),t("p",[e._v("第四次patchChidren")]),e._v(" "),t("img",{attrs:{src:n(482)}}),e._v(" "),t("p",[e._v("如果没有用到diff算法，而是依次patch虚拟dom树，那么如上稍微"),t("strong",[e._v("修改dom顺序")]),e._v("，就会在patch过程中没有一对正确的新老vnode，所以老vnode的节点没有一个可以复用，这样就需要重新创造新的节点，浪费了性能开销，这显然不是我们需要的。")]),e._v(" "),t("p",[e._v("那么diff算法的作用就来了。")]),e._v(" "),t("p",[e._v("diff作用就是在patch子vnode过程中，找到与新vnode对应的老vnode，复用真实的dom节点，避免不必要的性能开销")]),e._v(" "),t("h2",{attrs:{id:"key值得作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key值得作用"}},[e._v("#")]),e._v(" key值得作用?")]),e._v(" "),t("p",[e._v("在我们上述diff算法中，通过isSameVNodeType方法判断，来判断key是否相等判断新老节点。")]),e._v(" "),t("p",[e._v("isSameVNodeType方法:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("export function isSameVNodeType(n1: VNode, n2: VNode): boolean {\nreturn n1.type === n2.type && n1.key === n2.key\n}\n")])])]),t("p",[e._v("isSameVNodeType 作用就是判断当前vnode类型 和 vnode的 key是否相等")]),e._v(" "),t("p",[e._v("那么由此我们可以总结出？")]),e._v(" "),t("p",[e._v("在v-for循环中，key的作用是：通过判断newVnode和OldVnode的key是否相等，从而复用与新节点对应的老节点，节约性能的开销。")]),e._v(" "),t("h2",{attrs:{id:"如何正确使用key"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何正确使用key"}},[e._v("#")]),e._v(" 如何正确使用key?")]),e._v(" "),t("p",[e._v("①错误用法 1：用index做key")]),e._v(" "),t("p",[e._v("用index做key的效果实际和没有用diff算法是一样的，为什么这么说呢，下面我就用一幅图来说明：")]),e._v(" "),t("img",{attrs:{src:n(483)}}),e._v(" "),t("p",[e._v("如果所示当我们用index作为key的时候，无论我们怎么样移动删除节点，到了diff算法中都会从头到尾依次patch(图中：所有节点均未有效的复用)")]),e._v(" "),t("p",[e._v("②错误用法2 ：用index拼接其他值作为key。")]),e._v(" "),t("p",[e._v("当已用index拼接其他值作为索引的时候，因为每一个节点都找不到对应的key，导致所有的节点都不能复用,所有的新vnode都需要重新创建。都需要重新create")]),e._v(" "),t("p",[e._v("如图所示。\n"),t("img",{attrs:{src:n(484)}})]),e._v(" "),t("p",[e._v("③正确用法 ：用唯一值id做key(我们可以用前后端交互的数据源的id为key,但前提是后端必须保证id是唯一值)。")]),e._v(" "),t("p",[e._v("如图所示。每一个节点都做到了复用。起到了diff算法的真正作用。")]),e._v(" "),t("img",{attrs:{src:n(485)}}),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("Vue3.0diff算法新增了静态标记,从而进行vnode对比,")]),e._v(" "),t("p",[e._v("而Vue2.0是进行全量对比,其余知识点均是拓展")])])}),[],!1,null,null,null);t.default=s.exports}}]);